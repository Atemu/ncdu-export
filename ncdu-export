#!/usr/bin/python
# coding: utf-8

# Standalone ncdu export feature
# Copyright (C) 2015 Marcin Szewczyk, marcin.szewczyk[at]wodny.org
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function
import sys
import os
import os.path
import time
import re
import json
import codecs

PROGNAME = "py-ncdu-export"
__version__ = "0.5.0"

class WalkError:
    val = False

def get_info(path):
    S_BLKSIZE = 512
    name = os.path.basename(path) or "/"
    try:
        stat_result = os.lstat(path)
    except OSError:
        return dict((
            ("name", name),
            ("error", True),
        ))
    return dict((
        ("name", name),
        ("asize", stat_result.st_size),
        ("dsize", stat_result.st_blocks * S_BLKSIZE),
        ("ino", stat_result.st_ino),
        ("mtime", stat_result.st_mtime),
    ))

def get_info_string(path, options, walk_error=False):
    info = get_info(path)
    name = codecs.decode(info["name"], "utf-8", "replace")
    name = json.dumps(name)
    if info.get("error", False):
        return """{{"name":{0},"read_error":true}}""".format(name)
    else:
        return """{{"name":{0},"asize":{1},"dsize":{2},"ino":{3}{4}{5}}}""".format(
            name,
            info["asize"],
            info["dsize"],
            info["ino"],
            ",\"read_error\":true" if walk_error else "",
            ",\"mtime\":{0:.0f}".format(info["mtime"]) if options["mtime"] else ""
        )

def get_path_dirs(path):
    if not os.path.isabs(path):
        raise Exception("absolute path required")
    path_dirs = []
    path, tail = os.path.split(path)
    while tail != "":
        path_dirs.append(tail)
        path, tail = os.path.split(path)
    path_dirs.append(tail)
    path_dirs.reverse()
    return path_dirs

def main():
    options = dict(
        format=False,
        mtime=False
    )

    argv = []
    usage = False

    for arg in sys.argv[1:]:
        if arg.startswith("-"):
            for i in arg:
                if i == "f":
                    options["format"] = True
                if i == "m":
                    options["mtime"] = True
                if i == "h":
                    usage = True
        else:
            argv.append(arg)

    if len(argv) != 1:
        usage = True

    if usage:
        exit("{0} [-fm] dirname\n\t-f  format\n\t-m  include mtime".format(sys.argv[0]))

    dirname = argv[0]

    print(
        """[1,0,{{"progname":"{0}","progver":"{1}","timestamp":{2}}}""".format(
            PROGNAME,
            __version__,
            int(time.time())
        ),
        end=""
    )

    class PathLen:
        base = None
        curr = 0
        prev = 0

    path_len = PathLen()

    def handle_dir(current, path_len, options, walk_error=False):
        path_dirs = get_path_dirs(current)
        path_len.curr = len(path_dirs)
    
        lev_diff = path_len.curr - path_len.prev
        if lev_diff == 0:
            print("],")
        elif lev_diff < 0:
            print("]"*(-lev_diff+1)+",")
        else:
            print(",")
    
        print("{0}[{1}".format(
                "    "*(path_len.curr-path_len.base) if options["format"] else "",
                get_info_string(current, options, walk_error=walk_error)
            ),
            end=""
        )
    
        path_len.prev = path_len.curr

    def walk_error_handler(error):
        handle_dir(error.filename, path_len, options, walk_error=True)

    basedir = os.path.abspath(dirname)
    dirgen = os.walk(basedir, onerror=walk_error_handler)
    path_len.base = len(get_path_dirs(basedir))

    for current, subdirs, fnames in dirgen:
        handle_dir(current, path_len, options)
    
        for fname in fnames:
            print(",\n{0}{1}".format(
                    "    "*(path_len.curr-path_len.base) if options["format"] else "",
                    get_info_string(os.path.join(current, fname), options)
                ),
                end=""
            )
    
    lev_diff = len(get_path_dirs(basedir)) - path_len.prev - 1
    print("]"*(-lev_diff+1))

if __name__ == "__main__":
    main()
